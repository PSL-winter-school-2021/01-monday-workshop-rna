[
["introdution.html", "Report title Introdution Sources of inspiration Bibliography", " Report title Lorette Noiret, Nathalie Lehmann, Eric Van Leen 2021-02-05 Introdution Objectives : In this pratical session, you will learn : how to clean single cells data and extract high quality cells identify sub-populations of cells We will be using the R packages Seurat and apply it functionalities to subset of the data publilshied with Karaiskos et al ??. Sources of inspiration This course material is largely inspired by two great sources that we advised you to read in details: sincellTE 2020 : MA Dillies, A. Rausell, M Deloger, N. Servant, M. Thomas-Chollier, A. Paquet, cours6_TP_EDA_Normalization_2020.html Vignette Seurat Bibliography Karaiskos et al.The Drosophila embryo at single-cell transcriptome resolution. Science13 Oct 2017 : 194-199 "],
["working-with-seurat.html", " 1 Working with Seurat 1.1 Load the library 1.2 Import the data 1.3 Explore the Seurat data structure", " 1 Working with Seurat 1.1 Load the library library(Seurat) ## Loading required package: methods 1.2 Import the data scRNAseqdata are presented in a matrix, where each row represents a gene and each column represents a single cell with a raw count (UMI). In this pratical session, we will work with the data from “replicate3” published along with the article by Karaiskos. We will first load the text file then create a “Seurat object”, the data structure suitable to work with Seurat. raw_counts&lt;-read.csv2(file=&quot;data/data_day1/GSM2494785_dge_mel_rep3.txt&quot;, sep=&quot;\\t&quot;) raw_counts[1:3,1:5] ## GENE TCCCTAAAGTAN TTTAAGCTCTTN AGAGAGAATACA GCCCGTGGAGCA ## 1 128up 0 1 1 2 ## 2 14-3-3epsilon 426 371 438 380 ## 3 14-3-3zeta 64 54 58 58 print(dim(raw_counts)) ## [1] 17026 1586 Here we have the expression of 17 026 genes in 1586 cells. We will modify the table to have the field “GENE” as the rownames: rownames(raw_counts) = raw_counts$GENE raw_counts$GENE = NULL To work with Seurat, you need to create a Seurat Object. mydata &lt;- CreateSeuratObject(raw_counts, min.cells = 1, min.features = 200, project = &quot;mydata_scRNAseq&quot;) mydata ## An object of class Seurat ## 17024 features across 1579 samples within 1 assay ## Active assay: RNA (17024 features) While creating the object we can perform a first filtering : here we excluded cells that contains less than 200 genes (undersequenced cells or debris) and genes that are expressed in only 1 cell. Alternative: If you have a directory produce by CellRanger, you can use the function _\"read10X*_ directly. This function takes as argument the name of the folder containing the output of CellRanger (matrix.mtx, genes.tsv, barcodes.tsv). 1.3 Explore the Seurat data structure A Seurat object is not the easiest structure to work with, but with a but of practice you will appreciate its potentiality ! In Seurat, data are organised in different compartements (slots) which contains them-selves several compartements, which can them-selves contain sub compartments….Each compartment can used to store: * data from multiple modalities, such as RNAseq, spatial transcriptomics, ATAC-seq… For our session today, we will focus on RNAseq only (slot “assays”, sub-slot “RNA”) * general results regarding your data, such as the total number of UMI exexpressed (slot meta.data) * resultst of analyses (PCA loading or clustering results) slotNames(mydata) ## [1] &quot;assays&quot; &quot;meta.data&quot; &quot;active.assay&quot; &quot;active.ident&quot; &quot;graphs&quot; ## [6] &quot;neighbors&quot; &quot;reductions&quot; &quot;project.name&quot; &quot;misc&quot; &quot;version&quot; ## [11] &quot;commands&quot; &quot;tools&quot; You navigate through this hierachie using ‘@’ and ‘$’ signs. slotNames(mydata@assays$RNA) ## [1] &quot;counts&quot; &quot;data&quot; &quot;scale.data&quot; &quot;key&quot; ## [5] &quot;var.features&quot; &quot;meta.features&quot; &quot;misc&quot; In the slots associated RNA, you will store: counts : raw UMI (the data we imported) data : filtered/normalized counting matrix scale.data : normalize and scaled data (usually for PCA analyses) var.features: contains a list of genes genes that contribute strongly to cell-to-cell variation (see section on highly variable genes) We will see through this session how to fill in these fields. You can access the data by using the ‘@’ and ‘$’ sign, or by using the function GetAssayData function. GetAssayData(mydata, slot=&quot;counts&quot;)[1:3,1:5] ## 3 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## TCCCTAAAGTAN TTTAAGCTCTTN AGAGAGAATACA GCCCGTGGAGCA ACTAGACCAAGT ## 128up . 1 1 2 4 ## 14-3-3epsilon 426 371 438 380 358 ## 14-3-3zeta 64 54 58 58 35 # Alternative code : # mydata@assays$RNA@counts[1:3,1:5] In Seurat, data are stored as “dgCMatrix”, which is an efficient way o store an array with a lot of zero in a computer (sparse matrix). "],
["basic-single-cell-pipeline.html", " 2 Basic single cell pipeline 2.1 Remove “low quality cells” 2.2 Normalize the expression in cells", " 2 Basic single cell pipeline The steps below encompass the standard pre-processing workflow for scRNA-seq data. Filter out low quality cells : undersequenced cells, debris (broken cells or floating pieces of RNA) and multiplets (several cells in one droplets) Normalize the expression to reduce the sequencing biais. 2.1 Remove “low quality cells” The are a few metrics commonly used to filter out low quality cells : the number of unique genes detected in each cell : cells with low gene count : helps to remove empty droplets, debris and undersequenced cells. cells with high gene count : these cells are more likely to be cell doublets or multiplets. The number of multiplets expected in your sample is directly correlated with the number of cells you loaded in 10X. The more cells you loaded, the higher the chance is to have 2 or more cells in one droplet. total number of UMI detected within a cell the percentage of reads that map to the mitochondrial genome : low-quality / dying cells often exhibit extensive mitochondrial contamination Seurat allows you to easily explore QC (quality control) metrics and filter cells based on any user-defined criteria using the slot ‘meta.data’. 2.1.1 Number of genes detected per cell barplot(sort(mydata$nFeature_RNA), main=&quot;Number of genes detected/Cell&quot;, names.arg = &quot;&quot;) quantile(mydata$nFeature_RNA) ## 0% 25% 50% 75% 100% ## 235.0 705.5 1312.0 2593.5 6322.0 2.1.2 Number of UMIs per cell barplot(sort(mydata$nCount_RNA), main=&quot;Number of UMI/Cell&quot;,names.arg = &quot;&quot;) VlnPlot(mydata, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), ncol = 2) FeatureScatter(mydata, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) You aim while looking at these graphs is to define thresholds/cutoff that you will aply to filter cell out. Try to identify the cells that behave differently from the main population. 2.1.3 Percentage of mitochondrial genes To calculate the perentage of mitochonrial genes expressed in a cell, you must first provide a list of mitochondrial genes. In the paper, the authors did not provide their list. As a quick replacement, we will consider that mitochondrial genes are all the genes that starts with the pattern ‘mt:’. For a more refine analysis, you can use flybase or another source and carefully identify mitochondrial genes. We then use the PercentageFeatureSet function, which calculates the percentage of counts originating from a set of features. mydata[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(mydata, pattern = &quot;^mt:&quot;) # Alternative : if you have a list of mitochondrial genes #list = c(&quot;mTerf3&quot;,&quot;Mtpalpha&quot; ,&quot;mTTF&quot;) #mydata[[&quot;percent.mt2&quot;]] &lt;- PercentageFeatureSet(mydata, features=list_mito ) VlnPlot(mydata, features = &quot;percent.mt&quot;) FeatureScatter(mydata, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) FeatureScatter(mydata, feature1 = &quot;nFeature_RNA&quot;, feature2 = &quot;percent.mt&quot;) 2.1.4 Group exercice on filtering On of the most difficult parts of single cells pre-processing is to decide the threshold to define low and high quality cells. From the various graphs, decide the levels for low high quality cells dependant on the number of genes expressed per cell, the total UMIs per cell and the percentage of mitochonrial genes. Discuss as a group. # DEFINE THE CUTOFF VALUES AND VISUALIZE THE RESULTS minGene = 500 maxGene = 5800 minUMI = 12500 maxUMI = 60000 maxpct_mt = 18 # the function &quot;subset&quot; helps you to filter the cells # we create a new seurat object containing the filtred cells mydata_filtrd &lt;- subset(mydata, subset = nFeature_RNA &gt; minGene &amp; nFeature_RNA &lt; maxGene &amp; nCount_RNA &gt; minUMI &amp; nCount_RNA &lt; maxUMI &amp; percent.mt &lt; maxpct_mt) VlnPlot(mydata_filtrd, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) FeatureScatter(mydata_filtrd, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) FeatureScatter(mydata_filtrd, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) 2.2 Normalize the expression in cells After removing unwanted cells from the dataset, the next step is to normalize the data. The objective is to correct for the sequencing bias. As we noticed in the previous graphes, the cells do not have the same number of total UMI. This may be due biological differences (some cells express less RNA than other) but is likely to be the result of cell-specific sequencint biais (some cells have been less sequenced than other). We are going to apply a global scaling method, which supposes that all cells are about the same RNA content. It aims to remove cell-specific systematic biases by scaling expression measures within each cell by a constant factor. We use a “LogNormalize” method that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (here the median total UMI per cell), and log-transforms the result. mydata_filtrd &lt;- NormalizeData(mydata_filtrd, normalization.method = &quot;LogNormalize&quot;, scale.factor = median(mydata_filtrd$nCount_RNA)) The resulting data are stored in the ‘data’ slot Once you have pre-processed your data, you are ready for further analyses : identify sub-population of cells, pseudo-time analyses… "],
["identify-cell-populations.html", " 3 Identify cell populations 3.1 Select highly variables (hvg) 3.2 Dimension Reduction 3.3 Cluster cells", " 3 Identify cell populations In this section, we will analyse further the data and try to identify sub-populations of cells. The objective is to create clusters of cells, i.e to make group of cells that share similar expression profile. The mains steps are as follow : Select a subset of genes to perfom the downstream analyses Perform a dimension reduction Cluster the cells 3.1 Select highly variables (hvg) The downstream analyses (dimension reduction and then clustering) will se performed on the subset of genes. The aims is to exclude genes with minor biological relevance and decrease the computational load. # Find Variable Genes : mydata_filtrd &lt;- FindVariableFeatures(mydata_filtrd, selection.method = &quot;vst&quot;, nfeatures = 2000,verbose = FALSE) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(mydata_filtrd), 10) # you can also access the complete list using : list_hvg = mydata_filtrd@assays$RNA@var.features 3.2 Dimension Reduction 3.2.1 Scaling Expression of each gene is scaled (centered around its mean with a unit standard deviation). This step gives equal weight to all genes while performing the in the dimension reduction, and insure that the most expressed genes do not dominate. mydata_filtrd &lt;- ScaleData(mydata_filtrd) ## Centering and scaling data matrix The scaled data are stored in the ‘scaled’ slot. By default, scaling is only performed on the variable genes. ### PCA Even though, the gene selection step reduces the data considerably, there is a further need to reduce dimension to keep the most important variability in the data.There are several methods for dimension reduction, the most commonly used is PCA, but you can also check more single-cell specific methods that tries to cope with over-dispersion of the data such as ZIFA and pCMF. mydata_filtrd &lt;- RunPCA(mydata_filtrd, features = VariableFeatures(object = mydata_filtrd)) ## PC_ 1 ## Positive: CG4440, CG10035, Bacc, CG13427, Df31, Tom, bl, fax, CG15628, BobA ## hth, ed, CG5059, ci, tna, Gp150, sqd, sdt, l(3)neo38, N ## Ppa, grh, vfl, Dl, roX1, wech, HmgD, CR43887, ASPP, Brd ## Negative: nos, spz, del, CG8507, stai, CG14545, Sesn, shu, CG17698, CG6287 ## CanB2, BigH1, pgc, 26-29-p, stil, Eno, PyK, CG7530, krimp, aret ## CG17270, Taf12L, Cen, fabp, CG31689, Gapdh1, exu, CG17658, CG6967, CG9917 ## PC_ 2 ## Positive: Lac, ASPP, Ptr, cno, grh, cv-2, aop, CG2162, jbug, btsz ## sdt, crb, mew, Tom, fra, CG34383, 5-HT2A, CG34224, Doc1, CG45263 ## blot, hbs, Mipp1, ci, CG10176, pnr, wun2, dpp, bib, CG42788 ## Negative: twi, ventrally-expressed-protein-D, CG4500, Cyp310a1, sna, ltl, Ilp4, CG12177, CG16758, Mes2 ## stumps, if, htl, CG14688, CadN, zfh1, Mdr49, CG3036, Pka-C3, tin ## sty, Asph, sprt, Inx3, CR45361, Mef2, Nplp2, be, Act87E, Ndae1 ## PC_ 3 ## Positive: CG8147, srp, ps, Lapsyn, fkh, peb, CG2930, hkb, Doc3, Oatp74D ## CG15236, MRE23, exex, Gmap, Doc2, CG32053, Fas2, DNaseII, Ptx1, egr ## CG31431, ImpE2, kek1, mspo, tup, Doc1, sas, ush, CG18754, Pdp1 ## Negative: dan, SoxN, sca, ths, CG6398, CG5059, bl, lea, ImpL2, Imp ## Pino, rdx, neur, RnrS, Meltrin, sbb, brk, Shroom, noc, pyr ## mid, sog, danr, Toll-6, wb, slp1, lok, pico, Atg18a, path ## PC_ 4 ## Positive: aay, apt, Cys, sog, CG2930, phyl, mnd, fkh, CG32053, bib ## MRE23, DNaseII, brk, pDsRed, Gmap, RpL10Ab, CG8654, ps, Sox21a, CG18754 ## a, CG13427, Lac, CG31431, SoxN, exex, Ocho, Pdp1, vnd, Obp99a ## Negative: net, Ama, Nrt, CrebA, CycE, emc, mirr, zfh1, rst, how ## dap, chrb, Alk, pAbp, Glut4EF, hbs, CG45263, wake, kay, SNCF ## Dtg, CG14427, zen, spen, if, CadN, chn, ptc, vfl, shep ## PC_ 5 ## Positive: SNCF, zen, zen2, Ama, C15, Z600, CG13653, rho, net, kay ## Alk, CG8960, alphagamma-element:CR32865, opa, Dtg, CG14111, CG13454, CG13654, wntD, toc ## Ance, rst, dap, ush, Ect4, CG14915, CR44953, egr, E(spl)m5-HLH, Doc3 ## Negative: dm, Bsg, Tet, spoon, Dl, CG12535, Trf2, CG9821, mt:CoI, apt ## Hrb27C, sm, pAbp, Ssdp, CG34380, mt:ND1, Oatp74D, fs(1)h, Smr, sqd ## roX1, pum, msi, CR45874, CG45050, CG11138, AGO1, CG43736, east, RapGAP1 It is worth analysing the genes that contribute the most to each axes. It may help you to identify genes whose expression decrease/increase together. The DimHeatmap function in Seurat helps you to visualise the genes that are driving the components and allows to get some insight about the heterogeneity of the data. # Examine and visualize PCA results : print(mydata_filtrd[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: CG4440, CG10035, Bacc, CG13427, Df31 ## Negative: nos, spz, del, CG8507, stai ## PC_ 2 ## Positive: Lac, ASPP, Ptr, cno, grh ## Negative: twi, ventrally-expressed-protein-D, CG4500, Cyp310a1, sna ## PC_ 3 ## Positive: CG8147, srp, ps, Lapsyn, fkh ## Negative: dan, SoxN, sca, ths, CG6398 ## PC_ 4 ## Positive: aay, apt, Cys, sog, CG2930 ## Negative: net, Ama, Nrt, CrebA, CycE ## PC_ 5 ## Positive: SNCF, zen, zen2, Ama, C15 ## Negative: dm, Bsg, Tet, spoon, Dl VizDimLoadings(mydata_filtrd, dims = 1:2, reduction = &quot;pca&quot;) # Plot expression of gene driving principal component DimHeatmap(mydata_filtrd, dims = 1:2) After PCA, you need to decide how many components you want to keep (for UMAP and/or clustering). Seurat proposes a statistical methods with the function JackStraw. Alternatively you can plot the explained variance using the ElbowPlot. In practical case, around 30-50 principal components. library(ggplot2) DimPlot(mydata_filtrd, reduction = &quot;pca&quot;) ElbowPlot(mydata_filtrd) 3.3 Cluster cells There are two main steps Make a shared Nearest Neighbor graph : identify the k-nearest neighbours of each cell (by default Seurat takes k=20 neighbours). The distance is calculated using the coordinates from the PCA. Make clusters (community of cells) using Leiden algorithm. You will need to specify the number of clusters depends on the resolution parameter chosen (the higher, the more group) nPC = 20 mydata_filtrd &lt;- FindNeighbors(mydata_filtrd, dims = 1:nPC) ## Computing nearest neighbor graph ## Computing SNN mydata_filtrd &lt;- FindClusters(mydata_filtrd, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 399 ## Number of edges: 13157 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7522 ## Number of communities: 5 ## Elapsed time: 0 seconds Usually the clustering are presented using UMAP which visually separates the group more nicely than PCA. # If you haven&#39;t installed UMAP, you can do so via reticulate::py_install(packages = # &#39;umap-learn&#39;) mydata_filtrd &lt;- RunUMAP(mydata_filtrd, dims = 1:nPC) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 00:05:03 UMAP embedding parameters a = 0.9922 b = 1.112 ## 00:05:03 Read 399 rows and found 20 numeric columns ## 00:05:03 Using Annoy for neighbor search, n_neighbors = 30 ## 00:05:03 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 00:05:03 Writing NN index file to temp file /tmp/RtmprDQPdk/file1a8ad32098f2c8 ## 00:05:03 Searching Annoy index using 1 thread, search_k = 3000 ## 00:05:03 Annoy recall = 100% ## 00:05:03 Commencing smooth kNN distance calibration using 1 thread ## 00:05:04 Initializing from normalized Laplacian + noise ## 00:05:04 Commencing optimization for 500 epochs, with 14528 positive edges ## 00:05:05 Optimization finished DimPlot(mydata_filtrd, reduction = &quot;umap&quot;) ### Cluster identity One clustering is done, your biological work starts. You need to annotate the clusters. One way is to look at genes that are differentially expressed… but we won’t have the time to go in details # find all markers of cluster 1 cluster1.markers &lt;- FindMarkers(mydata_filtrd, ident.1 = 1, min.pct = 0.25) head(cluster1.markers, n = 5) ## p_val avg_logFC pct.1 pct.2 p_val_adj ## zfh1 2.095262e-57 2.189439 0.905 0.115 3.566974e-53 ## if 5.946009e-56 1.396971 0.842 0.069 1.012249e-51 ## htl 2.882346e-55 1.171352 0.842 0.069 4.906906e-51 ## sna 2.168411e-53 1.824705 0.937 0.181 3.691503e-49 ## Mes2 4.547330e-52 1.632343 1.000 0.283 7.741375e-48 VlnPlot(mydata_filtrd, features = c(&quot;Mes2&quot;, &quot;sna&quot;)) "],
["references.html", "References", " References {#Karaiskos} Karaiskos et al, Science 358, 194–199 (2017). The Drosophila embryo at single-cell transcriptome resolution. "],
["session-info.html", " 4 Session info", " 4 Session info ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/openblas-base/libblas.so.3 ## LAPACK: /usr/lib/libopenblasp-r0.2.18.so ## ## locale: ## [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=fr_FR.UTF-8 LC_COLLATE=fr_FR.UTF-8 ## [5] LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 ## [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] methods stats graphics grDevices utils datasets base ## ## other attached packages: ## [1] ggplot2_3.3.3 Seurat_3.1.1 ## ## loaded via a namespace (and not attached): ## [1] tsne_0.1-3 nlme_3.1-142 bitops_1.0-6 ## [4] RcppAnnoy_0.0.14 RColorBrewer_1.1-2 httr_1.4.2 ## [7] sctransform_0.2.0 tools_3.4.4 R6_2.5.0 ## [10] irlba_2.3.3 KernSmooth_2.23-15 uwot_0.1.4 ## [13] DBI_1.1.1 lazyeval_0.2.2 colorspace_2.0-0 ## [16] withr_2.4.0 npsurv_0.4-0 gridExtra_2.3 ## [19] tidyselect_1.1.0 compiler_3.4.4 plotly_4.9.1 ## [22] labeling_0.4.2 bookdown_0.17 caTools_1.17.1.2 ## [25] scales_1.1.1 lmtest_0.9-37 ggridges_0.5.1 ## [28] pbapply_1.4-3 rappdirs_0.3.1 stringr_1.4.0 ## [31] digest_0.6.27 rmarkdown_1.17 R.utils_2.9.0 ## [34] pkgconfig_2.0.3 htmltools_0.5.1 bibtex_0.4.2 ## [37] htmlwidgets_1.5.3 rlang_0.4.10 rstudioapi_0.13 ## [40] farver_2.0.3 generics_0.1.0 zoo_1.8-6 ## [43] jsonlite_1.7.2 ica_1.0-2 gtools_3.8.1 ## [46] dplyr_1.0.3 R.oo_1.23.0 magrittr_2.0.1 ## [49] Matrix_1.2-14 Rcpp_1.0.6 munsell_0.5.0 ## [52] ape_5.3 reticulate_1.18 lifecycle_0.2.0 ## [55] R.methodsS3_1.7.1 stringi_1.5.3 yaml_2.2.1 ## [58] gbRd_0.4-11 MASS_7.3-51.4 gplots_3.0.1.1 ## [61] Rtsne_0.15 plyr_1.8.6 grid_3.4.4 ## [64] parallel_3.4.4 gdata_2.18.0 listenv_0.7.0 ## [67] ggrepel_0.9.0 crayon_1.3.4 lattice_0.20-35 ## [70] cowplot_0.9.4 splines_3.4.4 SDMTools_1.1-221.1 ## [73] knitr_1.30 pillar_1.4.7 igraph_1.2.6 ## [76] reshape2_1.4.4 future.apply_1.3.0 codetools_0.2-15 ## [79] leiden_0.3.1 glue_1.4.2 evaluate_0.14 ## [82] lsei_1.2-0 metap_1.1 RcppParallel_5.0.2 ## [85] data.table_1.13.6 png_0.1-7 vctrs_0.3.6 ## [88] Rdpack_0.11-0 tidyr_1.1.2 gtable_0.3.0 ## [91] RANN_2.6.1 purrr_0.3.4 future_1.15.0 ## [94] xfun_0.19 rsvd_1.0.2 RSpectra_0.16-0 ## [97] viridisLite_0.3.0 survival_3.1-7 tibble_3.0.5 ## [100] cluster_2.1.0 globals_0.12.4 fitdistrplus_1.0-14 ## [103] ellipsis_0.3.1 ROCR_1.0-7 "]
]
