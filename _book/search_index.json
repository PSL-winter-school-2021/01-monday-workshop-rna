[["introdution.html", "Basic single-cell RNA-seq processing Introdution", " Basic single-cell RNA-seq processing Lorette Noiret, Nathalie Lehmann, Eric van Leen 2021-02-06 Introdution Objectives : In this pratical session, you will learn : how to clean single cells data and extract high quality cells identify sub-populations of cells We will be using the R package Seurat and apply it functionalities to subset the data published in (Karaiskos et al. 2017) (replicate n°3). Sources of inspiration This course material is largely inspired by two great sources that we advise you to read/use in details: sincellTE 2020 : MA Dillies, A. Rausell, M Deloger, N. Servant, M. Thomas-Chollier, A. Paquet, cours6_TP_EDA_Normalization_2020.html Vignette Seurat References "],["working-with-seurat.html", " 1 Working with Seurat 1.1 Load the library 1.2 Import the data 1.3 Explore the Seurat data structure", " 1 Working with Seurat 1.1 Load the library Seurat is an R package designed for the analysis of single-cell RNA-seq data. library(Seurat) 1.2 Import the data Single-cell RNA-seq data are presented in a matrix, where each row represents a gene and each column represents a single cell with a raw count (UMI). We first load the text file then create a “Seurat object”, the data structure suitable to work with Seurat. raw_counts &lt;- read.csv2(file=&quot;data/data_day1/GSM2494785_dge_mel_rep3.txt&quot;,sep=&quot;\\t&quot;) raw_counts[1:3,1:5] ## GENE TCCCTAAAGTAN TTTAAGCTCTTN AGAGAGAATACA GCCCGTGGAGCA ## 1 128up 0 1 1 2 ## 2 14-3-3epsilon 426 371 438 380 ## 3 14-3-3zeta 64 54 58 58 print(dim(raw_counts)) ## [1] 17026 1586 Here we have the expression of 17 026 genes in 1586 cells. To work with Seurat, you need to create a Seurat Object. Here, we create a Seurat object from our dataframe. We modify the table raw_counts to have the field GENE as the rownames. rownames(raw_counts) = raw_counts$GENE raw_counts$GENE = NULL While creating the Seurat object, we can perform a first filtering: we exclude cells that contain less than 200 genes (undersequenced cells or debris) and genes that are expressed in only 2 cells. mydata &lt;- CreateSeuratObject(raw_counts, min.cells = 2, min.features = 200) mydata ## An object of class Seurat ## 12511 features across 1579 samples within 1 assay ## Active assay: RNA (12511 features, 0 variable features) Alternative: if you have a directory produced by CellRanger, you create your Seurat object with the function read10X. This function takes as argument the name of the folder containing the output of CellRanger (matrix.mtx, genes.tsv, barcodes.tsv). 1.3 Explore the Seurat data structure A Seurat object is not the easiest structure to work with, but with a bit of practice you will learn to appreciate its potentiality. In Seurat, data are organised in different compartements (slots), which contain themselves several compartements, which can also contain sub-compartments, etc. Each compartment can be used to store: data from multiple modalities, such as RNAseq, spatial transcriptomics, ATAC-seq… For our session today, we will only focus on scRNAseq data (slot assays, sub-slot RNA) general results regarding your data, e.g. the total number of UMI expressed (slot meta.data) results of analyses: PCA components or clustering results slotNames(mydata) ## [1] &quot;assays&quot; &quot;meta.data&quot; &quot;active.assay&quot; &quot;active.ident&quot; &quot;graphs&quot; ## [6] &quot;neighbors&quot; &quot;reductions&quot; &quot;images&quot; &quot;project.name&quot; &quot;misc&quot; ## [11] &quot;version&quot; &quot;commands&quot; &quot;tools&quot; You navigate through this hierarchy using @ and $ signs. slotNames(mydata@assays$RNA) ## [1] &quot;counts&quot; &quot;data&quot; &quot;scale.data&quot; &quot;key&quot; ## [5] &quot;assay.orig&quot; &quot;var.features&quot; &quot;meta.features&quot; &quot;misc&quot; In the slots associated RNA, you can store: counts : raw UMI (the data we imported) data : filtered/normalized counting matrix scale.data : normalized and scaled data (usually for PCA analyses) var.features: contains a list of genes genes that contribute strongly to cell-to-cell variation (see section 3.1 on highly variable genes). You can access the data directly with the GetAssayData function. # mydata@assays$RNA@counts[1:3,1:5] GetAssayData(mydata, slot=&quot;counts&quot;)[1:3,1:5] ## 3 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## TCCCTAAAGTAN TTTAAGCTCTTN AGAGAGAATACA GCCCGTGGAGCA ACTAGACCAAGT ## 128up . 1 1 2 4 ## 14-3-3epsilon 426 371 438 380 358 ## 14-3-3zeta 64 54 58 58 35 In Seurat, data are stored as “dgCMatrix”, which is an efficient way to store an array with a lot of zeros in a computer (sparse matrix). "],["basic-single-cell-pipeline.html", " 2 Basic single cell pipeline 2.1 Remove “low quality” cells 2.2 Normalize the expression in cells", " 2 Basic single cell pipeline The steps below encompass the standard pre-processing workflow for scRNA-seq data. Filter out low quality cells: undersequenced cells, debris (broken cells or floating pieces of RNA) and multiplets (several cells in one droplets) Normalize the UMI expression to reduce the sequencing biais (some cells are less sequenced than others). 2.1 Remove “low quality” cells The are a few metrics commonly used to filter out low quality cells : the number of unique genes detected in each cell cells with low gene count : helps to remove empty droplets, debris and undersequenced cells. cells with high gene count : these cells are more likely to be cell doublets or multiplets. The number of multiplets expected in your sample is directly correlated with the number of cells you loaded in 10X. The more cells you loaded, the higher the chance is to have 2 or more cells in one droplet. the total number of UMI detected within a cell the total number of UMI and the number of genes are highly correlated. Looking at the scatter plot between these two variables helps you detect atypical cells. the percentage of reads that map to the mitochondrial genome low-quality / dying cells often exhibit extensive mitochondrial contamination Seurat allows you to easily explore these QC (quality control) metrics and filter out cells. 2.1.1 Number of genes detected per cell hist(mydata$nFeature_RNA, breaks = 200, xlab = &quot;n genes&quot;, main = &quot;Number of genes detected / cell&quot; ) #add a vertical line to your plot to help you choose a threshold abline(v = 6000 , col = &quot;red&quot;) quantile(mydata$nFeature_RNA) ## 0% 25% 50% 75% 100% ## 235.0 705.0 1308.0 2588.5 6298.0 2.1.2 Number of UMIs per cell hist(mydata$nCount_RNA, breaks = 50, xlab = &quot;Total UMIs per cell&quot;, main = &quot;Number of UMI / cell&quot; ) abline(v = 150000 , col = &quot;red&quot;) VlnPlot(mydata, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), ncol = 2) FeatureScatter(mydata, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) Your aim while looking at these graphs is to define the thresholds/cutoffs that you will apply to filter cells out. To do so, try to identify the cells that behave differently from the main population. 2.1.3 Percentage of mitochondrial genes To calculate the percentage of mitochondrial genes expressed in a cell, you must first provide a list of mitochondrial genes. In the paper, the authors did not provide their list. As a quick replacement, we will consider that mitochondrial genes are all the genes that starts with the pattern mt:. For a more refine analysis, you can use flybase or another source and carefully identify mitochondrial genes. We then use the PercentageFeatureSet function, which calculates the percentage of counts originating from a set of features. mydata[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(mydata, pattern = &quot;^mt:&quot;) # Alternative : if you have a list of mitochondrial genes #list = c(&quot;mTerf3&quot;,&quot;Mtpalpha&quot; ,&quot;mTTF&quot;) #mydata[[&quot;percent.mt2&quot;]] &lt;- PercentageFeatureSet(mydata, features=list_mito ) VlnPlot(mydata, features = &quot;percent.mt&quot;) FeatureScatter(mydata, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) FeatureScatter(mydata, feature1 = &quot;nFeature_RNA&quot;, feature2 = &quot;percent.mt&quot;) 2.1.4 Group exercise on filtering One of the most difficult parts of single cells pre-processing is to decide the thresholds to define low and high quality cells. From the various graphs above, decide the levels for low high quality cells dependent on the number of genes expressed per cell, the total UMIs per cell and the percentage of mitochonrial genes. Discuss your cutoff as a group. # DEFINE THE CUTOFF VALUES FOR EACH VARIABLE AND VISUALIZE THE RESULTS. minGene = maxGene = minUMI = maxUMI = maxpct_mt = # the function &quot;subset&quot; helps you to filter the cells # we create a new seurat object containing the filtred cells mydata_filtrd &lt;- subset(mydata, subset = nFeature_RNA &gt; minGene &amp; nFeature_RNA &lt; maxGene &amp; nCount_RNA &gt; minUMI &amp; nCount_RNA &lt; maxUMI &amp; percent.mt &lt; maxpct_mt) VlnPlot(mydata_filtrd, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) FeatureScatter(mydata_filtrd, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;percent.mt&quot;) FeatureScatter(mydata_filtrd, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) 2.2 Normalize the expression in cells As we noticed in the previous graphes, the cells do not have the same number of total UMIs. This may be due biological differences (some cells express less RNA than other) but is likely to be the result of cell-specific sequencing biais (some cells have been less sequenced than other). The normalization step aims to correct for this bias. We are going to apply a global scaling method, which supposes that all cells have about the same RNA content. The LogNormalize method normalizes the expression measurements for each cell by the total expression, multiplies this by a scale factor (here the median total UMI per cell), and log-transforms the result. mydata_filtrd &lt;- NormalizeData(mydata_filtrd, normalization.method = &quot;LogNormalize&quot;, scale.factor = median(mydata_filtrd$nCount_RNA)) The resulting data is stored in the data slot. Once you have pre-processed your data, you are ready for further analyses (e.g. identify sub-population of cells, pseudo-time analyses). "],["identify-cell-populations.html", " 3 Identify cell populations 3.1 Select highly variables (hvg) 3.2 Dimension reduction", " 3 Identify cell populations In this section, we will analyse further the data and try to identify sub-populations of cells. The objective is to create clusters of cells, i.e to make groups of cells that share similar expression profile. The main steps are as follow : Select a subset of genes to perfom the downstream analyses Perform a dimension reduction Cluster the cells 3.1 Select highly variables (hvg) The downstream analyses (dimension reduction and then clustering) will be performed on the subset of genes. The aims are to exclude genes with minor biological relevance and decrease the computational load. # Find Variable Genes : mydata_filtrd &lt;- FindVariableFeatures(mydata_filtrd, selection.method = &quot;vst&quot;, nfeatures = 2000, verbose = FALSE) # Identify the 10 most highly variable genes top10 &lt;- head(VariableFeatures(mydata_filtrd), 10) # you can also access the complete list using : list_hvg = mydata_filtrd@assays$RNA@var.features 3.2 Dimension reduction Before performing a dimension reduction technique, it is usually advised to scale the data. 3.2.1 Scaling Expression of each gene is scaled (centered around its mean with a unit standard deviation). This step gives equal weight to all genes while performing the dimension reduction, and insures that the most expressed genes do not dominate. mydata_filtrd &lt;- ScaleData(mydata_filtrd) ## Centering and scaling data matrix The scaled data are stored in the scaled slot. By default, scaling is only performed on the variable genes. 3.2.2 PCA Even though, the gene selection step reduces the data considerably, there is a further need to reduce dimension to keep the most important variability in the data. There are several methods for dimension reduction, the most commonly used is PCA, but you can also check ICA or more single-cell specific methods that tries to cope with over-dispersion of the data such as ZIFA and pCMF. mydata_filtrd &lt;- RunPCA(mydata_filtrd, features = VariableFeatures(object = mydata_filtrd)) ## PC_ 1 ## Positive: nos, spz, del, CG8507, stai, CG14545, Sesn, shu, CG17698, CG6287 ## CanB2, BigH1, pgc, 26-29-p, stil, PyK, Eno, CG7530, krimp, aret ## CG17270, Taf12L, Cen, fabp, CG31689, Gapdh1, exu, CG17658, CG6967, CG9917 ## Negative: CG4440, CG10035, Bacc, CG13427, Df31, Tom, bl, fax, CG15628, BobA ## hth, ed, CG5059, ci, tna, Gp150, sqd, sdt, l(3)neo38, N ## Ppa, grh, vfl, Dl, roX1, wech, HmgD, CR43887, ASPP, Brd ## PC_ 2 ## Positive: twi, ventrally-expressed-protein-D, CG4500, Cyp310a1, sna, ltl, Ilp4, CG12177, CG16758, Mes2 ## stumps, if, htl, CG14688, CadN, zfh1, Mdr49, CG3036, Pka-C3, tin ## sty, Asph, sprt, Inx3, CR45361, Mef2, Nplp2, be, Act87E, Ndae1 ## Negative: Lac, ASPP, Ptr, cno, grh, cv-2, aop, jbug, CG2162, btsz ## sdt, crb, mew, Tom, fra, CG34383, 5-HT2A, CG34224, Doc1, CG45263 ## blot, hbs, Mipp1, ci, CG10176, pnr, wun2, dpp, bib, CG42788 ## PC_ 3 ## Positive: CG8147, srp, ps, Lapsyn, fkh, peb, CG2930, hkb, Doc3, Oatp74D ## CG15236, MRE23, exex, Gmap, Doc2, CG32053, Fas2, DNaseII, Ptx1, egr ## CG31431, ImpE2, kek1, mspo, tup, Doc1, sas, ush, CG18754, Pdp1 ## Negative: dan, SoxN, sca, ths, CG6398, CG5059, bl, lea, ImpL2, Imp ## Pino, rdx, neur, RnrS, Meltrin, sbb, brk, Shroom, noc, pyr ## mid, sog, danr, Toll-6, wb, slp1, lok, pico, Atg18a, path ## PC_ 4 ## Positive: aay, apt, Cys, sog, CG2930, phyl, mnd, fkh, CG32053, bib ## MRE23, DNaseII, brk, pDsRed, RpL10Ab, Gmap, ps, CG8654, Sox21a, CG18754 ## a, CG13427, CG31431, Lac, SoxN, exex, Pdp1, Ocho, vnd, Obp99a ## Negative: net, Ama, Nrt, CrebA, CycE, emc, mirr, zfh1, rst, chrb ## dap, how, pAbp, Alk, hbs, Glut4EF, CG45263, wake, kay, SNCF ## Dtg, CG14427, zen, spen, if, CadN, chn, ptc, vfl, shep ## PC_ 5 ## Positive: SNCF, zen, zen2, Ama, C15, Z600, CG13653, rho, net, kay ## Alk, CG8960, opa, alphagamma-element:CR32865, CG14111, Dtg, CG13454, CG13654, wntD, toc ## Ance, rst, ush, dap, Ect4, CG14915, CR44953, egr, Doc3, E(spl)m5-HLH ## Negative: dm, Bsg, Tet, spoon, Dl, CG12535, Trf2, CG9821, mt:CoI, apt ## sm, Hrb27C, pAbp, Ssdp, CG34380, mt:ND1, Oatp74D, fs(1)h, Smr, roX1 ## sqd, pum, msi, CR45874, CG45050, CG11138, AGO1, CG43736, east, RapGAP1 3.2.2.1 Explore the PCA results It is worth analysing the genes that contribute the most to each axes. It may help you to identify genes whose expression decrease/increase together. The DimHeatmap function in Seurat helps you to visualize the genes that are driving the components and allows to get some insight about the heterogeneity of the data. # Examine and visualize PCA results : print(mydata_filtrd[[&quot;pca&quot;]], dims = 1:5, nfeatures = 5) ## PC_ 1 ## Positive: nos, spz, del, CG8507, stai ## Negative: CG4440, CG10035, Bacc, CG13427, Df31 ## PC_ 2 ## Positive: twi, ventrally-expressed-protein-D, CG4500, Cyp310a1, sna ## Negative: Lac, ASPP, Ptr, cno, grh ## PC_ 3 ## Positive: CG8147, srp, ps, Lapsyn, fkh ## Negative: dan, SoxN, sca, ths, CG6398 ## PC_ 4 ## Positive: aay, apt, Cys, sog, CG2930 ## Negative: net, Ama, Nrt, CrebA, CycE ## PC_ 5 ## Positive: SNCF, zen, zen2, Ama, C15 ## Negative: dm, Bsg, Tet, spoon, Dl VizDimLoadings(mydata_filtrd, dims = 1:2, reduction = &quot;pca&quot;) # Plot expression of gene driving principal component DimHeatmap(mydata_filtrd, dims = 1:2) 3.2.2.2 Choose the number of axes After PCA, you need to decide how many components you want to keep for UMAP and/or clustering. Seurat proposes a statistical methods with the function JackStraw. Alternatively you can plot the explained variance using the ElbowPlot. In practical case, you can keep around 20-50 principal components. library(ggplot2) DimPlot(mydata_filtrd, reduction = &quot;pca&quot;) ElbowPlot(mydata_filtrd) 3.2.3 Cluster cells There are two main steps to cluster the cells: Make a shared Nearest Neighbor graph: Identify the k-nearest neighbours (k-nn) of each cell (by default Seurat takes \\(k=20\\) neighbours). The distance between cells is calculated using the coordinates obtained with the PCA. Make clusters (community of cells) using Leiden algorithm. The number of clusters depends on the resolution parameter chosen: the higher the value of the parameter is, the more groups you will get. nPC = 30 # number of PC kepts for the analysis # k-nn graoh mydata_filtrd &lt;- FindNeighbors(mydata_filtrd, dims = 1:nPC) ## Computing nearest neighbor graph ## Computing SNN # make the clusters mydata_filtrd &lt;- FindClusters(mydata_filtrd, resolution = 0.5) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 399 ## Number of edges: 15473 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7319 ## Number of communities: 4 ## Elapsed time: 0 seconds Usually the clustering results are presented using UMAP which visually separates the group more nicely than PCA. mydata_filtrd &lt;- RunUMAP(mydata_filtrd, dims = 1:nPC) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 00:32:50 UMAP embedding parameters a = 0.9922 b = 1.112 ## 00:32:50 Read 399 rows and found 30 numeric columns ## 00:32:50 Using Annoy for neighbor search, n_neighbors = 30 ## 00:32:50 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 00:32:51 Writing NN index file to temp file /tmp/RtmpCyjudL/file1af1f1652c6a8d ## 00:32:51 Searching Annoy index using 1 thread, search_k = 3000 ## 00:32:51 Annoy recall = 100% ## 00:32:51 Commencing smooth kNN distance calibration using 1 thread ## 00:32:52 Initializing from normalized Laplacian + noise ## 00:32:52 Commencing optimization for 500 epochs, with 14628 positive edges ## 00:32:53 Optimization finished DimPlot(mydata_filtrd, reduction = &quot;umap&quot;) 3.2.4 Group exercise Try to play with the number of PCs and the clustering parameters. How could you decide which set of parameters is the best ? 3.2.5 Understand your clusters Hurray, you succeed to cluster your cells ! Now, your biological work starts. You need to annotate the clusters, and check if your results make sense. One way is to look at genes that are differentially expressed. # find all markers of cluster 1 cluster1.markers &lt;- FindMarkers(mydata_filtrd, ident.1 = 1, min.pct = 0.25) head(cluster1.markers, n = 5) ## p_val avg_logFC pct.1 pct.2 p_val_adj ## Mes2 2.017839e-57 1.755482 1.000 0.264 2.524519e-53 ## stumps 2.291799e-55 1.504331 0.825 0.068 2.867270e-51 ## sna 1.130465e-54 1.918047 0.913 0.169 1.414324e-50 ## twi 4.368472e-54 2.240741 0.932 0.226 5.465395e-50 ## zfh1 6.612339e-53 2.117815 0.854 0.111 8.272697e-49 You can also check if some genes of interest are specifically expressed in some clusters. VlnPlot(mydata_filtrd, features = c(&quot;Mes2&quot;, &quot;sna&quot;)) "],["session-info.html", " 4 Session info", " 4 Session info ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.4 LTS ## ## Matrix products: default ## BLAS/LAPACK: /import/kg_csbws03/lehmann/miniconda3/envs/cellid/lib/libopenblasp-r0.3.12.so ## ## locale: ## [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=fr_FR.UTF-8 LC_COLLATE=fr_FR.UTF-8 ## [5] LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 ## [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggplot2_3.3.3 Seurat_3.2.3 ## ## loaded via a namespace (and not attached): ## [1] nlme_3.1-151 matrixStats_0.57.0 RcppAnnoy_0.0.18 ## [4] RColorBrewer_1.1-2 httr_1.4.2 sctransform_0.3.2 ## [7] tools_4.0.3 R6_2.5.0 irlba_2.3.3 ## [10] rpart_4.1-15 KernSmooth_2.23-18 uwot_0.1.10 ## [13] mgcv_1.8-33 DBI_1.1.1 lazyeval_0.2.2 ## [16] colorspace_2.0-0 withr_2.4.0 gridExtra_2.3 ## [19] tidyselect_1.1.0 compiler_4.0.3 plotly_4.9.3 ## [22] labeling_0.4.2 bookdown_0.21 scales_1.1.1 ## [25] spatstat.data_1.7-0 lmtest_0.9-38 ggridges_0.5.3 ## [28] pbapply_1.4-3 goftest_1.2-2 spatstat_1.64-1 ## [31] stringr_1.4.0 digest_0.6.27 spatstat.utils_1.20-2 ## [34] rmarkdown_2.6 pkgconfig_2.0.3 htmltools_0.5.1 ## [37] parallelly_1.23.0 limma_3.46.0 fastmap_1.0.1 ## [40] htmlwidgets_1.5.3 rlang_0.4.10 rstudioapi_0.13 ## [43] shiny_1.5.0 farver_2.0.3 generics_0.1.0 ## [46] zoo_1.8-8 jsonlite_1.7.2 ica_1.0-2 ## [49] dplyr_1.0.3 magrittr_2.0.1 patchwork_1.1.1 ## [52] Matrix_1.3-2 Rcpp_1.0.6 munsell_0.5.0 ## [55] abind_1.4-5 reticulate_1.18 lifecycle_0.2.0 ## [58] stringi_1.5.3 yaml_2.2.1 MASS_7.3-53 ## [61] Rtsne_0.15 plyr_1.8.6 grid_4.0.3 ## [64] parallel_4.0.3 listenv_0.8.0 promises_1.1.1 ## [67] ggrepel_0.9.1 crayon_1.3.4 deldir_0.2-9 ## [70] miniUI_0.1.1.1 lattice_0.20-41 cowplot_1.1.1 ## [73] splines_4.0.3 tensor_1.5 knitr_1.30 ## [76] pillar_1.4.7 igraph_1.2.6 reshape2_1.4.4 ## [79] future.apply_1.7.0 codetools_0.2-18 leiden_0.3.6 ## [82] glue_1.4.2 evaluate_0.14 data.table_1.13.6 ## [85] vctrs_0.3.6 png_0.1-7 httpuv_1.5.5 ## [88] polyclip_1.10-0 gtable_0.3.0 RANN_2.6.1 ## [91] purrr_0.3.4 tidyr_1.1.2 scattermore_0.7 ## [94] future_1.21.0 assertthat_0.2.1 xfun_0.20 ## [97] rsvd_1.0.3 mime_0.9 xtable_1.8-4 ## [100] RSpectra_0.16-0 later_1.1.0.1 survival_3.2-7 ## [103] viridisLite_0.3.0 tibble_3.0.5 cluster_2.1.0 ## [106] globals_0.14.0 fitdistrplus_1.1-3 ellipsis_0.3.1 ## [109] ROCR_1.0-11 "]]
